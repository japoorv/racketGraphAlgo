**Benchmarks**

**Results folder has two benchmark csv files that I ran on my machine with the following configurations  
Intel® Core™ i7-10510U CPU @ 1.80GHz × 8, 16GB RAM, GeForce MX250/PCIe/SSE2 / GeForce MX250/PCIe/SSE2, 1 TB SSD, Ubuntu**

**Installation of packages** 
* Install python packages using the requirements.txt provided.

**Generating Benchmarks on your machine**

**test.py**
1) The script test.py generates weighted random graphs using networkx library (make sure you have installed all packages in requirements.txt)
   The generation of the graph is a costly task for large n hence complete graphs were generated till n=100 and after that random trees were generated for the purpose of analysis.
   The generation of the graph can be tweaked in the gen_graph(number of nodes) function.
2) After generating the weighted graph the command generates the racket script with the appropriate instruction as in the test cases files to run benchmarks on.
3) In addition to calculating the shortest path the whole distance list is temporarily dumped onto a file along with the desired distance list (from the networkx library). This was done inorder to check the correctness of the implementation of the algorithm. It is recommended to comment these lines once the implementation is verified.
4) All the generated files are automaticsally removed after every analysis. 

**Usage : python3 test.py <initial_number_of_node>  <final_number_of_node>  < step > which actually does the analysis on the graphs having nodes from initial_number_of_node to final_number_of_nodes with the gap between each of them specified by step. Eg. python3 test.py 1 1000 10**

**test.sh**
1) This basically is responsible for benchmarking the RSS, time taken by the entire racket script. This is called from test.py on each of the generated racket file for returning the  result of Max RSS, total time.

**The entire list of memory, time for each data point is automatically written in the memory, time files generated by Python via pickle**

**The files memory, time that are generated are similar to the ones present in results**

**Note: In the end after the benchmark has finished running. The output memory, time files are in the same folder as test.py (or otherwise mentioned). The generation of graphs and loading of the data from the files can automatically be done by running the jupyter notebook analysis.ipynb**
